package main

import (
	"bufio"
	"fmt"
	"io"
	"net/http"
	"net/http/httptest"
	"os"
	"sort"
	"strings"

	fake "kubevirt.io/kubevirt/pkg/monitoring/vms/prometheus"
	promvm "kubevirt.io/kubevirt/pkg/monitoring/vms/prometheus" // import for prometheus metrics
	_ "kubevirt.io/kubevirt/pkg/virt-controller/watch"
)

const (
	docFileName = "metrics.md"

	headerMarkdown = `# KubeVirt metrics

This document aims to help users that are not familiar with all metrics exposed by different KubeVirt components. 
All metrics documented here are auto-generated by the utility tool ` + "`tools/doc-generator`" + ` and reflect exactly what is being exposed.

## Kubevirt specific metrics

#### kubevirt_info
Version information. 
`
	footerMarkdown = `
# Developing new metrics

After developing new metrics or changing old ones, please run ` + "`make generate`" + ` to regenerate this document.
Metrics will be separated in different sections according to these rules:

* VMI metrics: metrics that contain ` + "`kubevirt_vmi_`" + `
* Virt-Controller metrics: metrics that contain ` + "`_virt_controller`" + `

If you feel that the new metric doesn't follow these rules, please change ` + "`doc-generator` with your needs."

	vmiHeaderMarkdown            = "## VMI metrics"
	virtControllerHeaderMarkdown = "## Virt-Controller metrics"
)

func main() {
	req, err := http.NewRequest(http.MethodGet, "/metrics", nil)
	checkError(err)

	recorder := httptest.NewRecorder()

	handler := promvm.Handler(1)

	fake.RegisterFakeCollector()

	handler.ServeHTTP(recorder, req)

	if status := recorder.Code; status == http.StatusOK {
		substrings := []string{"kubevirt_vmi", "_virt_controller"}
		metrics := parseMetrics(recorder.Body, substrings)

		// Delete if already exists
		checkError(os.Remove(docFileName))

		// Start writing file
		writeConstMarkdown(headerMarkdown)
		writeConstMarkdown(vmiHeaderMarkdown)
		writeMetricsMarkdown(metrics, "kubevirt_vmi_")
		writeConstMarkdown(virtControllerHeaderMarkdown)
		writeMetricsMarkdown(metrics, "_virt_controller")
		writeConstMarkdown(footerMarkdown)
	} else {
		panic(recorder.Code)
	}
}

// parseMetrics will return a map where the metric name is the key and metric help text is the value
func parseMetrics(r io.Reader, substrings []string) map[string]string {
	metrics := map[string]string{}
	scan := bufio.NewScanner(r)
	for scan.Scan() {
		line := scan.Text()

		for _, substring := range substrings {
			// Help lines have both metric name and metric help text
			if strings.Contains(line, substring) && strings.HasPrefix(line, "# HELP ") {
				helpSlice := strings.Split(line, " ")
				name := helpSlice[2]
				metrics[name] = strings.Join(helpSlice[3:], " ")
			}
		}
	}
	if scan.Err() != nil {
		panic(fmt.Errorf("Failed to parse metrics from prometheus endpoint, %v", scan.Err()))
	}
	return metrics
}

func writeConstMarkdown(markdown string) {
	doc, err := os.OpenFile(docFileName, os.O_APPEND|os.O_WRONLY|os.O_CREATE, 0755)
	checkError(err)
	defer doc.Close()

	doc.WriteString(markdown)
	doc.WriteString("\n")
}

// writeMetricsMarkdown can be used as a generic writer for metrics
func writeMetricsMarkdown(metrics map[string]string, substring string) {
	var markdown string

	keys := make([]string, len(metrics))
	for k := range metrics {
		keys = append(keys, k)
	}
	// Necessary to always write metrics in same order
	sort.Strings(keys)

	for _, metric := range keys {
		if strings.Contains(metric, substring) {
			markdown += "#### " + metric + "\n"
			markdown += metrics[metric] + "\n"
			markdown += "\n\n"
		}
	}
	writeConstMarkdown(markdown)
}

func checkError(err error) {
	if err != nil {
		panic(err)
	}
}
